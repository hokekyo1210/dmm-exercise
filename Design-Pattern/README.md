# デザインパターン

## 参考文献
- Goの実装: https://github.com/monochromegane/go_design_pattern
- qiitaのよくまとまってる記事: https://qiita.com/i-tanaka730/items/c63c6c22abd1477e0ba0
- Java言語で学ぶデザインパターン入門

## 生成に関するパターン
- Abstract Factory
    - インスタンスに関連する一連の処理を持つFactoryクラスによりインスタンスを生成するパターン
- Builder
    - オブジェクトの生成ロジックを抽象化する、生成ロジック(Builder)は利用者が任意のものを選択しDirectorに差し込む
- Factory Method
    - インスタンスの生成に用いる関数群をインタフェース化、具体的な生成処理をサブクラスで行う
    - 割と使うイメージ
- Prototype
    - 新規のインスタンスはインスタンスコピーで生成する
- Singleton
    - コンストラクタを外部エクスポートせず、インスタンスを取得する関数を利用して1つのインスタンスを使い回す


構造に関するパターン
- Adapter(Wrapper)
    - 既存のクラスに1枚クラスを被せる形で必要なメソッドを実装する
        - 既存のクラスに手を加えずに機能を実現出来る
        - デバッグを楽に出来る
        - MVCっぽさがあるような気もする
- Bridge
    - よくわからん
- Composite
    - 容器と中身を同一化
    - 例えばDirectoryとFileを同一のEntryとして扱えるように設計することでツリー構造による再帰的な処理をやりやすくする
- Decorator
    - 本質的にはCompositeと同じなのでは
    - ラッピングしていくことで機能を追加できる
- Facade
    - 複雑なシステムに対してシンプルな窓口を用意する
    - Utilみたいなイメージ
- Flyweight
    - Singletonに近いなにか
    - インスタンスを使いまわしてメモリ節約
- Proxy
    - 重たい処理を遅延実行するための代理クラスを作る
    - 初期化に時間がかかるシステムなどで利用

振る舞いに関するパターン
- Chain of Responsibility
    - 手続き的な処理を行う際に処理の順番を柔軟に変更出来るようにする設計
    - 処理をたらい回しにするイメージ(処理出来るインスタンスが処理する)
- Command
    - 命令をオブジェクトとして表現し、Chain of Responsibilityのように連結することで命令の履歴をとったりundo redoの実装が楽になる
- Interpreter
    - 構文解析する際に構文木を表現するためのデザインパターン
    - 1つの規則を1つのクラスで表す
- Iterator
    - 集合体の要素に対し順番にアクセスする処理を行うためのパターン
- Mediator
    - 複数のオブジェクト間の調整をするために各オブジェクトからの問い合わせを受け、適宜判断を行い指示を出す仲介人となるクラスを利用するパターン
    - 実装しないとイメージしづらそう
- Memento
    - undo, redo, 状態の保存などを実現するためにスナップショット用のクラスを作成するパターン
- Observer
    - 観察対象の状態が変化すると観察者に対して通知が走るような設計
    - SwingのListenerのイメージ, 予めイベントを受け取るインスタンスをaddActionListenerなどで登録しておく
- State
    - 状態をクラスとして表現し、クラスを切り替えることで「状態の変化」を表す方式
- Strategy
    - アルゴリズムをinterfaceで抽象化し、任意に切り替えられるようにする
- Template Method
    - 同一のコードがいろいろな場所で複数出現しないようにクラスの継承などを利用して使い回す手法
- Visitor
    - データ構造と処理を分離する方式
    - データ構造の中を走査するVisitorクラスを用意し、処理を任せる
        - データ構造に対して新しい処理を追加したいときは新しいVisitorを作れば良い
