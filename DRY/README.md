# DRY原則

Golangによる例を示す。

## 基礎事項

- DRY = Don't Repeat Yourself
- 繰り返しを避けようねという意味

## 例

例えばint配列の中身をすべて出力したいとき

```
func main() {
	a := []int{5, 2, 6, 3, 1, 4}
	b := []int{9, 1, 3, 5, 6, 2}
	for _, v := range a {
		println(v)
	}
	for _, v := range b {
		println(v)
	}
}
```

↑こうするより↓の方が良い

```
func printIntArray(a []int) {
	for _, v := range a {
		println(v)
	}
}

func main() {
	a := []int{5, 2, 6, 3, 1, 4}
	b := []int{9, 1, 3, 5, 6, 2}
	printIntArray(a)
	printIntArray(b)
}
```

基本的には重複コードをなるべくなくそうという考え方。
ただしやりすぎは抽象化された関数が大量に生えてしまい可読性が下がる可能性があるためやりすぎ良くない。

また, DBに関するコードをスキーマ設計を元に一から書くことがこのDRY原則に違反するという考え方もある。
スキーマ定義とコード上の定義が重複して存在することになるため, 片方の変更を行った場合もう片方も書き換える必要が生じるからである。
これを回避するために, golangでは例えばSQLBoilerといったDBに関するコードを自動生成するコードジェネレーターを用いる必要がある。


## 他の定義とか

- > 「探す癖をつける」
    - 同様のコードをあちこちに生やさないために, レビューも有効
    - また, そのために命名規則を統一するなどの活動が開発チームには求められる
- > コードを見れば自明なことをわざわざコメントに書かない
    - コードを書き換えると同時にコメントも書き換える必要が生じるため, DRY原則に反する
- > 私たちが行う作業（タスク）については「繰り返しを避けよ」
    - docker-composeを用いて環境構築の手間を省く
    - CIを組んで細かいチェックを機械化するなど

## 参考文献

- [DRY原則をもう一度 -コンカレント・エンジニアリング-](https://qiita.com/Koki_jp/items/d5f1b5f277b581888a1f)
- [SQLBoiler](https://github.com/volatiletech/sqlboiler)