# Solid原則 - OCP

Golangによる例で示す。

## 基礎事項

- OCP = open/closed principle
- 機能の拡張の際、既存コード修正せず、新しくコードを追加するだけで対応できる設計にすること
    - 具体的には...
    - システムをコンポーネントに分割して、コンポーネントの依存関係を階層構造にする。そして、上位レベルのコンポーネントが下位レベルのコンポーネントの変更の影響を受けないように依存関係を設計してやる。

![Clean Architecture 図8-3](https://i.stack.imgur.com/cgQD0.png)

## 例

```
type Animal interface {
    bark()
    eat()
}

type Dog struct{} //Animalを実装する。bark()およびeat()の具体的な実装省略
type Cat struct{} //Dogと同様
```
たとえば↑のAnimalというインタフェースを作った上でそれを実装したDogやCatといった型を作れば, インタフェースを介すことでDogやCat型の存在を意識せずにbark()やeat()を呼ぶことが出来る！
またその場合, あとからBird型を追加するなどの拡張もAnimalを実装した型を新規に作るだけでよく, 既存のコードへの影響が非常に限定的。
(とても暴力的な言い方をするなら, クラスの関数を直接呼ぶよりもインタフェースを介して呼んだほうが拡張性が上がるよね, ぐらいの認識でいる)
Java書いてたときによくやってたなあ。


## 他の定義とか

- > 開放/閉鎖原則に従ったソフトウェアは、既存のソースコードを変更することなく、振る舞いを変更することができる。
    - なるほど
- > オブジェクト指向プログラミングには、「グローバル変数を使ってはならない」「インスタンス変数はすべてprivateにする」などのさまざまなノウハウや豊富なデザインパターンがあり、開放/閉鎖原則はそれらの根底にある。


## 参考文献

- [SOLID原則を理解するためにGo言語で書いてみた](https://qiita.com/MAKOTODA/items/976f47ea036e35c7538d)
- [オープン・クローズドの原則 - TypeScriptで学ぶSOLID原則 part 1](https://qiita.com/ryo2132/items/01f0fcb8ff27353f8ecb)
- [開放/閉鎖原則](https://ja.wikipedia.org/wiki/%E9%96%8B%E6%94%BE/%E9%96%89%E9%8E%96%E5%8E%9F%E5%89%87)